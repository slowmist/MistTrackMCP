import { MistTrackClient, MistTrackResponse } from './misttrackClient';
import { MistTrackClientManager } from './misttrackClientManager';
import { MistTrackConfig } from '../MistTrackMCPServer';
import { withApiKeyCheck } from './decorators';

/**
 * Client class for advanced blockchain analysis using MistTrack API
 * Focuses on cryptocurrency flow analysis and address label statistics
 */
export class AnalysisClient {
  private misttrackClient: MistTrackClient;

  /**
   * Initialize analysis client
   * 
   * @param misttrackClient MistTrack API client instance, if not provided will be obtained from manager
   * @param config MistTrack API configuration object, used to initialize client
   */
  constructor(misttrackClient?: MistTrackClient, config?: MistTrackConfig) {
    // Modified client acquisition method to ensure correctly configured client instance
    if (misttrackClient) {
      this.misttrackClient = misttrackClient;
    } else {
      // Use MistTrackClientManager to get instance without passing config parameter
      this.misttrackClient = MistTrackClientManager.getClient();
    }
    
    // Use withApiKeyCheck higher-order function to wrap methods requiring API Key
    this.getAddressOverview = withApiKeyCheck(this.getAddressOverview.bind(this));
    this.getAddressOverviewAsText = withApiKeyCheck(this.getAddressOverviewAsText.bind(this));
  }

  /**
   * Get address overview information and process into human and LLM friendly format
   * 
   * @param coin Cryptocurrency type (ETH, BTC, etc.)
   * @param address Address to analyze
   * @returns Formatted dictionary with address overview information
   */
  async getAddressOverview(coin: string, address: string): Promise<any> {
    // Get raw overview data
    const response = await this.misttrackClient.getAddressOverview(coin, address);
    
    if (!response.success) {
      return {
        success: false,
        msg: response.msg || "Failed to get address overview",
        formatted_data: null
      };
    }
    
    // Get raw data
    const data = response.data || {};
    
    // Prepare formatted data
    const formatted_data: any = {
      "Address": address,
      "Coin": coin,
      "Basic Information": {
        "Current Balance": `${data.balance || 0} ${coin}`,
        "Total Transactions": data.txs_count || 0,
        "Total Received": `${data.total_received || 0} ${coin}`,
        "Total Spent": `${data.total_spent || 0} ${coin}`,
        "Received Transactions Count": data.received_txs_count || 0,
        "Spent Transactions Count": data.spent_txs_count || 0,
      },
      "Activity Status": {
        "First Transaction Time": this._formatTimestamp(data.first_seen || 0),
        "Last Transaction Time": this._formatTimestamp(data.last_seen || 0),
        "Active Duration": this._getActiveDuration(data.first_seen || 0, data.last_seen || 0),
      },
      "Fund Analysis": {
        "Net Fund Inflow": `${(data.total_received || 0) - (data.total_spent || 0)} ${coin}`,
        "Average Transaction Amount": `${this._calcAvgTxAmount(data)} ${coin}`,
        "Transaction Frequency": this._analyzeTxFrequency(data),
      }
    };
    
    // Add brief analysis
    formatted_data["Brief Analysis"] = this._generateBriefAnalysis(data, coin);
    
    return {
      success: true,
      msg: "",
      formatted_data: formatted_data,
      raw_data: data  // Keep raw data for reference
    };
  }

  /**
   * Convert address overview data to formatted text
   * 
   * @param formatted_data Formatted data generated by getAddressOverview method
   * @returns Formatted text string, can be saved as txt file
   */
  formatOverviewAsText(formatted_data: any): string {
    if (!formatted_data) {
      return "No data available";
    }
    
    const lines: string[] = [];
    
    // Title
    lines.push("=".repeat(50));
    lines.push("Blockchain Address Analysis Report");
    lines.push("=".repeat(50));
    lines.push("");
    
    // Basic information
    lines.push(`Address: ${formatted_data["Address"] || "Unknown"}`);
    lines.push(`Coin: ${formatted_data["Coin"] || "Unknown"}`);
    lines.push("");
    
    // Brief analysis
    lines.push("-".repeat(50));
    lines.push("【Brief Analysis】");
    lines.push(formatted_data["Brief Analysis"] || "No analysis available");
    lines.push("-".repeat(50));
    lines.push("");
    
    // Basic information
    lines.push("【Basic Information】");
    const basic_info = formatted_data["Basic Information"] || {};
    for (const [key, value] of Object.entries(basic_info)) {
      lines.push(`  ${key}: ${value}`);
    }
    lines.push("");
    
    // Activity status
    lines.push("【Activity Status】");
    const activity_info = formatted_data["Activity Status"] || {};
    for (const [key, value] of Object.entries(activity_info)) {
      lines.push(`  ${key}: ${value}`);
    }
    lines.push("");
    
    // Fund analysis
    lines.push("【Fund Analysis】");
    const financial_info = formatted_data["Fund Analysis"] || {};
    for (const [key, value] of Object.entries(financial_info)) {
      lines.push(`  ${key}: ${value}`);
    }
    lines.push("");
    
    // Footer
    lines.push("=".repeat(50));
    lines.push(`Report Generation Time: ${new Date().toISOString().replace('T', ' ').substring(0, 19)}`);
    lines.push("=".repeat(50));
    
    return lines.join("\n");
  }

  /**
   * Get address overview information and return directly as formatted text
   * 
   * @param coin Cryptocurrency type (ETH, BTC, etc.)
   * @param address Address to analyze
   * @returns Formatted text string, can be saved as txt file
   */
  async getAddressOverviewAsText(coin: string, address: string): Promise<string> {
    const overview_result = await this.getAddressOverview(coin, address);
    
    if (typeof overview_result === 'string') {
      return overview_result; // This is an API key error message
    }
    
    if (!overview_result.success) {
      return `Failed to get address data: ${overview_result.msg || "Unknown error"}`;
    }
    
    const formatted_data = overview_result.formatted_data || {};
    return this.formatOverviewAsText(formatted_data);
  }

  /**
   * Convert Unix timestamp to human readable date-time format
   */
  private _formatTimestamp(timestamp: number): string {
    if (!timestamp) {
      return "Unknown";
    }
    try {
      const dt = new Date(timestamp * 1000);
      return dt.toISOString().replace('T', ' ').substring(0, 19) + " UTC";
    } catch {
      return `${timestamp} (timestamp)`;
    }
  }

  /**
   * Calculate address active duration
   */
  private _getActiveDuration(first_seen: number, last_seen: number): string {
    if (!first_seen || !last_seen) {
      return "Unknown";
    }
    
    try {
      const duration_seconds = last_seen - first_seen;
      if (duration_seconds <= 0) {
        return "Unknown or data anomaly";
      }
      
      // Calculate days, hours, etc.
      const days = Math.floor(duration_seconds / (60 * 60 * 24));
      const remaining = duration_seconds % (60 * 60 * 24);
      const hours = Math.floor(remaining / (60 * 60));
      
      if (days > 365) {
        const years = Math.floor(days / 365);
        const remaining_days = days % 365;
        return `${years} years ${remaining_days} days`;
      } else if (days > 30) {
        const months = Math.floor(days / 30);
        const remaining_days = days % 30;
        return `${months} months ${remaining_days} days`;
      } else if (days > 0) {
        return `${days} days ${hours} hours`;
      } else {
        const minutes = Math.floor((remaining % (60 * 60)) / 60);
        return `${hours} hours ${minutes} minutes`;
      }
    } catch {
      return "Calculation error";
    }
  }

  /**
   * Calculate average transaction amount
   */
  private _calcAvgTxAmount(data: any): number {
    const total_amount = (data.total_received || 0) + (data.total_spent || 0);
    const total_txs = (data.received_txs_count || 0) + (data.spent_txs_count || 0);
    
    if (total_txs === 0) {
      return 0;
    }
    
    return Number((total_amount / total_txs).toFixed(4));
  }

  /**
   * Analyze transaction frequency
   */
  private _analyzeTxFrequency(data: any): string {
    const first_seen = data.first_seen || 0;
    const last_seen = data.last_seen || 0;
    const txs_count = data.txs_count || 0;
    
    if (!first_seen || !last_seen || !txs_count || first_seen >= last_seen) {
      return "Cannot analyze";
    }
    
    const duration_days = (last_seen - first_seen) / (60 * 60 * 24);
    if (duration_days < 1) {
      return "Insufficient data";
    }
    
    const daily_tx = txs_count / duration_days;
    
    if (daily_tx < 0.1) {
      return `Very Low (average ${Math.round(1/daily_tx)} days per transaction)`;
    } else if (daily_tx < 1) {
      return `Low (average ${Math.round(1/daily_tx)} days per transaction)`;
    } else if (daily_tx < 5) {
      return `Medium (average ${daily_tx.toFixed(1)} transactions per day)`;
    } else if (daily_tx < 20) {
      return `High (average ${daily_tx.toFixed(1)} transactions per day)`;
    } else {
      return `Very High (average ${daily_tx.toFixed(1)} transactions per day)`;
    }
  }

  /**
   * Generate brief address analysis summary
   */
  private _generateBriefAnalysis(data: any, coin: string): string {
    // Prepare data for analysis
    const balance = data.balance || 0;
    const total_received = data.total_received || 0;
    const total_spent = data.total_spent || 0;
    const received_count = data.received_txs_count || 0;
    const spent_count = data.spent_txs_count || 0;
    const first_seen_timestamp = data.first_seen || 0;
    const last_seen_timestamp = data.last_seen || 0;
    
    // Calculate some metrics
    const net_flow = total_received - total_spent;
    const current_ratio = total_received > 0 ? balance / total_received : 0;
    const tx_ratio = received_count > 0 ? spent_count / received_count : 0;
    
    // Analyze address characteristics
    const characteristics: string[] = [];
    
    // Account age
    if (first_seen_timestamp > 0) {
      const first_seen_date = new Date(first_seen_timestamp * 1000);
      const age_days = Math.floor((Date.now() - first_seen_date.getTime()) / (1000 * 60 * 60 * 24));
      if (age_days > 365 * 2) {
        characteristics.push("old account");
      } else if (age_days < 30) {
        characteristics.push("new account");
      }
    }
    
    // Activity status
    if (last_seen_timestamp > 0) {
      const last_seen_date = new Date(last_seen_timestamp * 1000);
      const days_since_last_tx = Math.floor((Date.now() - last_seen_date.getTime()) / (1000 * 60 * 60 * 24));
      if (days_since_last_tx < 7) {
        characteristics.push("recently active");
      } else if (days_since_last_tx > 180) {
        characteristics.push("long-term inactive");
      }
    }
    
    // Transaction patterns
    if (current_ratio > 0.9 && net_flow > 0) {
      characteristics.push("savings-type address");
    } else if (current_ratio < 0.1 && tx_ratio > 0.9) {
      characteristics.push("circulation-type address");
    } else if (spent_count > 100 && received_count > 100) {
      characteristics.push("high-frequency trading address");
    }
    
    // Fund scale
    if (balance > 100 || total_received > 1000) {
      characteristics.push("large funds");
    } else if (balance < 0.1 && total_received < 1) {
      characteristics.push("small funds");
    }
    
    // Form final description
    let summary = "";
    if (characteristics.length > 0) {
      const characteristics_text = characteristics.join(", ");
      summary = `This address is a ${characteristics_text}, `;
    } else {
      summary = "This address ";
    }
    
    if (balance > 0) {
      summary += `currently holds ${balance} ${coin}, `;
    }
    
    summary += `historically received ${total_received} ${coin}, sent ${total_spent} ${coin}, `;
    summary += `with net inflow of ${net_flow} ${coin}.`;
    
    return summary;
  }
} 